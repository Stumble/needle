// Package musicsrepo is generated by needle v0.4.2-1-ga5cc79e-dirty, DO NOT CHANGE.
package musicsrepo

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"time"
)

// edit result before dump
type BeforeDump func(m *Music)

// Musics - main interface.
type Musics interface {
	GetMusics(ctx context.Context, options ...Option) ([]Music, error)
	Search(ctx context.Context, args *SearchArgs, options ...Option) ([]Music, error)
	ListMusicsLTSpotifyID(ctx context.Context, args *ListMusicsLTSpotifyIDArgs, options ...Option) ([]Music, error)
	GetMusicByAuthorAndName(ctx context.Context, args *GetMusicByAuthorAndNameArgs, options ...Option) (*Music, error)
	InsertMusic(ctx context.Context, args *InsertMusicArgs, key0 *GetMusicsArgs, val0 []Music, key1 *ListMusicsLTSpotifyIDArgs, val1 []Music, options ...Option) (sql.Result, error)

	Check(ctx context.Context) error
	Load(ctx context.Context, data []byte) error
	Dump(ctx context.Context, beforeDump ...BeforeDump) ([]byte, error)
}

type musics struct {
	cache Cache
	exec  DBExecuter
}

// NewMusics - nil cache indicates nocache.
func NewMusics(c Cache, exec DBExecuter) Musics {
	return &musics{cache: c, exec: exec}
}

// implementation.

// Music - the main struct.
type Music struct {
	Author       string    `json:"author,omitempty"`
	Name         string    `json:"name,omitempty"`
	Album        string    `json:"album,omitempty"`
	SpotifyID    int64     `json:"spotify_id,omitempty"`
	DownloadPath *string   `json:"download_path,omitempty"`
	ReleasedAt   time.Time `json:"released_at,omitempty"`
	CreatedAt    time.Time `json:"created_at,omitempty"`
	UpdatedAt    time.Time `json:"updated_at,omitempty"`
}

// nolint: unused
func (r *Music) scan(sc rowScanner) error {
	return sc.Scan(
		&r.Author,
		&r.Name,
		&r.Album,
		&r.SpotifyID,
		&r.DownloadPath,
		&r.ReleasedAt,
		&r.CreatedAt,
		&r.UpdatedAt)
}

// nolint: unused
func (r *Music) arglist() (args []interface{}, inlens []int) {
	args = append(args, r.Author)
	args = append(args, r.Name)
	args = append(args, r.Album)
	args = append(args, r.SpotifyID)
	args = append(args, r.DownloadPath)
	args = append(args, r.ReleasedAt)
	args = append(args, r.CreatedAt)
	args = append(args, r.UpdatedAt)
	return
}

func (s musics) Check(ctx context.Context) error {
	stmts := []string{
		GetMusicsStmt,
		SearchStmt,
		ListMusicsLTSpotifyIDStmt,
		GetMusicByAuthorAndNameStmt,
		InsertMusicStmt,
	}
	for _, v := range stmts {
		err := func(stmt string) error {
			st, err := s.exec.Prepare(ctx, v)
			if err != nil {
				return err
			}
			defer st.Close()
			return nil
		}(v)
		if err != nil {
			return err
		}
	}
	return nil
}

func (s musics) Dump(ctx context.Context, beforeDump ...BeforeDump) ([]byte, error) {
	sql := "SELECT Author,Name,Album,SpotifyID,DownloadPath,ReleasedAt,CreatedAt,UpdatedAt FROM Musics ORDER BY Author,Name"
	rows, err := s.exec.Query(ctx, sql)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var rst []Music
	for rows.Next() {
		row := Music{}
		err := row.scan(rows)
		if err != nil {
			return nil, err
		}
		for _, applyBeforeDump := range beforeDump {
			applyBeforeDump(&row)
		}
		rst = append(rst, row)
	}

	// must shut it down with no error.
	rerr := rows.Close()
	if rerr != nil {
		return nil, rerr
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	bytes, err := json.MarshalIndent(rst, "", "  ")
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

func (s musics) Load(ctx context.Context, data []byte) error {
	rows := make([]Music, 0)
	err := json.Unmarshal(data, &rows)
	if err != nil {
		return err
	}
	for _, row := range rows {
		arglist, _ := row.arglist()
		_, err := s.exec.Exec(
			ctx,
			"INSERT INTO Musics (Author,Name,Album,SpotifyID,DownloadPath,ReleasedAt,CreatedAt,UpdatedAt) VALUES (?,?,?,?,?,?,?,?)",
			arglist...)
		if err != nil {
			return err
		}
	}
	return nil
}

// GetMusicsArgs -
type GetMusicsArgs struct {
}

// Key - cache key
func (r *GetMusicsArgs) Key() string {
	return fmt.Sprintf("GetMusics")
}

func (r *GetMusicsArgs) arglist() (args []interface{}, inlens []int) {
	return
}

func (s musics) GetMusics(ctx context.Context, options ...Option) ([]Music, error) {
	args := &GetMusicsArgs{}
	exec := s.getExec(options)
	nocache := s.isCacheNoRead(options)
	if s.cache == nil {
		return s.getMusics(ctx, exec, args)
	}
	rst := new([]Music)
	err := s.cache.Get(ctx, args.Key(), rst, time.Duration(5000000000),
		func() (interface{}, error) {
			return s.getMusics(ctx, exec, args)
		}, nocache)
	return *rst, err

}

func (s musics) getMusics(ctx context.Context, exec DBExecuter, args *GetMusicsArgs) ([]Music, error) {
	sql := GetMusicsStmt
	arglist, inlens := args.arglist()
	sql, err := replaceInCond(sql, inlens...)
	if err != nil {
		return nil, err
	}
	rows, err := exec.Query(ctx, sql, arglist...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var rst []Music
	for rows.Next() {
		row := Music{}
		err := row.scan(rows)
		if err != nil {
			return nil, err
		}
		rst = append(rst, row)
	}

	// must shut it down with no error.
	rerr := rows.Close()
	if rerr != nil {
		return nil, rerr
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return rst, err
}

// SearchArgs -
type SearchArgs struct {
	Name string
}

// Key - cache key
func (r *SearchArgs) Key() string {
	return fmt.Sprintf("Search:%s", valueToString(r.Name))
}

func (r *SearchArgs) arglist() (args []interface{}, inlens []int) {
	args = append(args, r.Name)
	return
}

func (s musics) Search(ctx context.Context, args *SearchArgs, options ...Option) ([]Music, error) {
	exec := s.getExec(options)
	nocache := s.isCacheNoRead(options)
	if s.cache == nil {
		return s.search(ctx, exec, args)
	}
	rst := new([]Music)
	err := s.cache.Get(ctx, args.Key(), rst, time.Duration(5000000000),
		func() (interface{}, error) {
			return s.search(ctx, exec, args)
		}, nocache)
	return *rst, err

}

func (s musics) search(ctx context.Context, exec DBExecuter, args *SearchArgs) ([]Music, error) {
	sql := SearchStmt
	arglist, inlens := args.arglist()
	sql, err := replaceInCond(sql, inlens...)
	if err != nil {
		return nil, err
	}
	rows, err := exec.Query(ctx, sql, arglist...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var rst []Music
	for rows.Next() {
		row := Music{}
		err := row.scan(rows)
		if err != nil {
			return nil, err
		}
		rst = append(rst, row)
	}

	// must shut it down with no error.
	rerr := rows.Close()
	if rerr != nil {
		return nil, rerr
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return rst, err
}

// ListMusicsLTSpotifyIDArgs -
type ListMusicsLTSpotifyIDArgs struct {
	SpotifyID int64
}

// Key - cache key
func (r *ListMusicsLTSpotifyIDArgs) Key() string {
	return fmt.Sprintf("ListMusicsLTSpotifyID:%s", valueToString(r.SpotifyID))
}

func (r *ListMusicsLTSpotifyIDArgs) arglist() (args []interface{}, inlens []int) {
	args = append(args, r.SpotifyID)
	return
}

func (s musics) ListMusicsLTSpotifyID(ctx context.Context, args *ListMusicsLTSpotifyIDArgs, options ...Option) ([]Music, error) {
	exec := s.getExec(options)
	nocache := s.isCacheNoRead(options)
	if s.cache == nil {
		return s.listMusicsLTSpotifyID(ctx, exec, args)
	}
	rst := new([]Music)
	err := s.cache.Get(ctx, args.Key(), rst, time.Duration(5000000000),
		func() (interface{}, error) {
			return s.listMusicsLTSpotifyID(ctx, exec, args)
		}, nocache)
	return *rst, err

}

func (s musics) listMusicsLTSpotifyID(ctx context.Context, exec DBExecuter, args *ListMusicsLTSpotifyIDArgs) ([]Music, error) {
	sql := ListMusicsLTSpotifyIDStmt
	arglist, inlens := args.arglist()
	sql, err := replaceInCond(sql, inlens...)
	if err != nil {
		return nil, err
	}
	rows, err := exec.Query(ctx, sql, arglist...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var rst []Music
	for rows.Next() {
		row := Music{}
		err := row.scan(rows)
		if err != nil {
			return nil, err
		}
		rst = append(rst, row)
	}

	// must shut it down with no error.
	rerr := rows.Close()
	if rerr != nil {
		return nil, rerr
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return rst, err
}

// GetMusicByAuthorAndNameArgs -
type GetMusicByAuthorAndNameArgs struct {
	Author string
	Name   string
}

// Key - cache key
func (r *GetMusicByAuthorAndNameArgs) Key() string {
	return fmt.Sprintf("GetMusicByAuthorAndName:%s:%s", valueToString(r.Author),
		valueToString(r.Name))
}

func (r *GetMusicByAuthorAndNameArgs) arglist() (args []interface{}, inlens []int) {
	args = append(args, r.Author)
	args = append(args, r.Name)
	return
}

func (s musics) GetMusicByAuthorAndName(ctx context.Context, args *GetMusicByAuthorAndNameArgs, options ...Option) (*Music, error) {
	exec := s.getExec(options)
	nocache := s.isCacheNoRead(options)
	if s.cache == nil {
		return s.getMusicByAuthorAndName(ctx, exec, args)
	}
	rst := new(*Music)
	err := s.cache.Get(ctx, args.Key(), rst, time.Duration(300000000000),
		func() (interface{}, error) {
			return s.getMusicByAuthorAndName(ctx, exec, args)
		}, nocache)
	return *rst, err

}

func (s musics) getMusicByAuthorAndName(ctx context.Context, exec DBExecuter, args *GetMusicByAuthorAndNameArgs) (*Music, error) {
	sql := GetMusicByAuthorAndNameStmt
	arglist, inlens := args.arglist()
	sql, err := replaceInCond(sql, inlens...)
	if err != nil {
		return nil, err
	}
	rows, err := exec.Query(ctx, sql, arglist...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var rst *Music
	if rows.Next() {
		rst = &Music{}
		err := rst.scan(rows)
		if err != nil {
			return nil, err
		}
	}

	// must shut it down with no error.
	rerr := rows.Close()
	if rerr != nil {
		return nil, rerr
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return rst, err
}

// InsertMusicArgs -
type InsertMusicArgs struct {
	Author       string
	Name         string
	Album        string
	SpotifyID    int64
	DownloadPath *string
	ReleasedAt   time.Time
}

func (r *InsertMusicArgs) arglist() (args []interface{}, inlens []int) {
	args = append(args, r.Author)
	args = append(args, r.Name)
	args = append(args, r.Album)
	args = append(args, r.SpotifyID)
	args = append(args, r.DownloadPath)
	args = append(args, r.ReleasedAt)
	return
}

func (s musics) InsertMusic(ctx context.Context, args *InsertMusicArgs, key0 *GetMusicsArgs, val0 []Music, key1 *ListMusicsLTSpotifyIDArgs, val1 []Music, options ...Option) (sql.Result, error) {
	sql := InsertMusicStmt
	exec := s.getExec(options)
	arglist, inlens := args.arglist()
	sql, err := replaceInCond(sql, inlens...)
	if err != nil {
		return nil, err
	}
	rst, err := exec.Exec(ctx, sql, arglist...)
	if err != nil {
		return rst, err
	}
	if s.cache == nil {
		return rst, nil
	}
	_ = exec.Invalidate(func() error {
		var anyErr error
		if key0 != nil {
			var err error
			if val0 != nil {
				err = s.cache.Set(ctx, key0.Key(), val0, time.Duration(5000000000))
			} else {
				err = s.cache.Invalidate(ctx, key0.Key())
			}
			if err != nil {
				anyErr = err
			}
		}
		if key1 != nil {
			var err error
			if val1 != nil {
				err = s.cache.Set(ctx, key1.Key(), val1, time.Duration(5000000000))
			} else {
				err = s.cache.Invalidate(ctx, key1.Key())
			}
			if err != nil {
				anyErr = err
			}
		}
		return anyErr
	})
	return rst, nil
}

//// SQL Statements
// Table Schema
var CreateTableStmt = "CREATE TABLE IF NOT EXISTS Musics (Author VARCHAR(200) NOT NULL,Name VARCHAR(200) NOT NULL,Album VARCHAR(200) NOT NULL,SpotifyID INT NOT NULL,DownloadPath TEXT,ReleasedAt DATETIME NOT NULL,CreatedAt DATETIME NOT NULL,UpdatedAt DATETIME NOT NULL,PRIMARY KEY(Author, Name),UNIQUE(Author, Name),INDEX(Author, ReleasedAt)) ENGINE = InnoDB DEFAULT CHARACTER SET = UTF8MB4 DEFAULT COLLATE = UTF8MB4_UNICODE_CI"

// Mutations and queries SQLs.

var GetMusicsStmt = "SELECT Musics.Author,Musics.Name,Musics.Album,Musics.SpotifyID,Musics.DownloadPath,Musics.ReleasedAt,Musics.CreatedAt,Musics.UpdatedAt FROM Musics"

var SearchStmt = "SELECT Musics.Author,Musics.Name,Musics.Album,Musics.SpotifyID,Musics.DownloadPath,Musics.ReleasedAt,Musics.CreatedAt,Musics.UpdatedAt FROM Musics WHERE Musics.Name LIKE ?"

var ListMusicsLTSpotifyIDStmt = "SELECT Musics.Author,Musics.Name,Musics.Album,Musics.SpotifyID,Musics.DownloadPath,Musics.ReleasedAt,Musics.CreatedAt,Musics.UpdatedAt FROM Musics WHERE Musics.SpotifyID>?"

var GetMusicByAuthorAndNameStmt = "SELECT Musics.Author,Musics.Name,Musics.Album,Musics.SpotifyID,Musics.DownloadPath,Musics.ReleasedAt,Musics.CreatedAt,Musics.UpdatedAt FROM Musics WHERE Musics.Author=? AND Musics.Name=?"

var InsertMusicStmt = "INSERT INTO Musics (Musics.Author,Musics.Name,Musics.Album,Musics.SpotifyID,Musics.DownloadPath,Musics.ReleasedAt,Musics.CreatedAt,Musics.UpdatedAt) VALUES (?,?,?,?,?,?,NOW(),NOW())"

//// Misc helpers
type Option struct {
	v interface{}
}

func TxExec(exec DBExecuter) Option {
	return Option{v: txExecOption{exec: exec}}
}

type txExecOption struct {
	exec DBExecuter
}

func CacheNoRead() Option {
	return Option{v: cacheOption{noread: true}}
}

type cacheOption struct {
	noread bool
}

// nolint: unused
func (s musics) getExec(options []Option) DBExecuter {
	for _, option := range options {
		switch v := option.v.(type) {
		case txExecOption:
			return v.exec
		}
	}
	return s.exec
}

// nolint: unused
func (s musics) isCacheNoRead(options []Option) bool {
	for _, option := range options {
		switch v := option.v.(type) {
		case cacheOption:
			return v.noread
		}
	}
	return false
}

////  utils
// replace the (?)s to (?,?,?...)s. The number of ? is @p sz
// XXX(yumin): we use place holder to replace first, to avoid real one (?).
func replaceInCond(sql string, sz ...int) (string, error) {
	const listPlaceholderSymbol = "$#L#$"
	sql = strings.Replace(sql, "(?)", listPlaceholderSymbol, len(sz))
	for _, listsz := range sz {
		if listsz == 0 {
			return sql, ErrEmptyListArg
		}
		var builder strings.Builder
		if listsz > 0 {
			builder.WriteString("(")
			builder.WriteString("?")
			for i := 1; i < listsz; i++ {
				builder.WriteString(",?")
			}
			builder.WriteString(")")
		}
		sql = strings.Replace(sql, listPlaceholderSymbol, builder.String(), 1)
	}
	return sql, nil
}

// support T(int64, float64, string, bool, time.Time), *T, []T, and *[]T.
func valueToString(input interface{}) string {
	val := reflect.ValueOf(input)
	if !val.IsValid() {
		return "<nil>"
	}
	switch val.Kind() {
	case reflect.Int64, reflect.Int:
		return strconv.FormatInt(val.Int(), 10)
	case reflect.Float64:
		return strconv.FormatFloat(val.Float(), 'g', -1, 64)
	case reflect.String:
		return val.String()
	case reflect.Bool:
		if val.Bool() {
			return "true"
		}
		return "false"
	case reflect.Ptr:
		if val.IsNil() {
			return "<nil>"
		}
		return valueToString(val.Elem().Interface())
	case reflect.Array, reflect.Slice:
		v := val
		str := "{"
		for i := 0; i < v.Len(); i++ {
			if i > 0 {
				str += ", "
			}
			str += valueToString(v.Index(i).Interface())
		}
		str += "}"
		return str
	case reflect.Struct:
		i := val.Interface()
		if t, ok := i.(time.Time); ok {
			return strconv.FormatInt(t.Unix(), 10)
		}
		panic("valueToString: unsupported struct " + val.Type().String())
	default:
		panic("valueToString: can't print type " + val.Type().String())
	}
}

var _ = fmt.Sprint("")
var _ = time.Now()
var _ = strings.Compare("", "")
var _ = &sql.Rows{}
var _ = context.Background()
var _ = json.RawMessage{}

//// dependency interfaces
// ErrEmptyListArg passing an empty list argument at runtime.
var ErrEmptyListArg = errors.New("ErrEmptyListArg")

// PassThroughFunc is the function that hits the db.
type PassThroughFunc = func() (interface{}, error)

// Cache is the interface that the cache layer must statisfy.
type Cache interface {
	// Get returns value of f(). The value will be saved into target and
	// cached in redis and inmemcache, if configured.
	// Inputs:
	// queryKey	 - key used in cache
	// target	 - receive the cached value, must be pointer
	// expire 	 - expiration of cache key
	// f		 - actual call that hits underlying data source
	// noCache 	 - whether force read from data source
	Get(ctx context.Context, queryKey string, target interface{}, expire time.Duration, f PassThroughFunc, noCache bool) error

	// Set explicitly set a cache key to a val
	// Inputs:
	// key	  - key to set
	// val	  - val to set
	// ttl    - ttl of key
	Set(ctx context.Context, key string, val interface{}, ttl time.Duration) error

	// Invalidate explicitly invalidates a cache key
	// Inputs:
	// key    - key to invalidate
	Invalidate(ctx context.Context, key string) error
}

// InvalidateFunc is the type of function that invalidate cache.
type InvalidateFunc = func() error

// DBExecuter wraps transaction and non-transaction db calls
type DBExecuter interface {
	Invalidate(InvalidateFunc) error
	Query(ctx context.Context, unprepared string, args ...interface{}) (*sql.Rows, error)
	Exec(ctx context.Context, unprepared string, args ...interface{}) (sql.Result, error)
	Prepare(ctx context.Context, query string) (*sql.Stmt, error)
}

// rowScanner is implemented by sql.Row and sql.Rows
type rowScanner interface {
	Scan(dest ...interface{}) error
}
