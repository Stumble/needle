// Package {{.PkgName}} is generated by needle {{.NeedleVersion}}, DO NOT CHANGE.
package {{.PkgName}}

import (
	"context"
	"database/sql"
	"strings"
	"time"
    "fmt"
    "reflect"
    "strconv"
    "errors"
    "encoding/json"
)

// edit result before dump
type BeforeDump func(m *{{.MainStructName}})

// {{.InterfaceName}} - main interface.
type {{.InterfaceName}} interface {
{{range .InterfaceSignatures}}
{{- .}}
{{end}}
    Check(ctx context.Context) error
    Load(ctx context.Context, data []byte) error
    Dump(ctx context.Context, beforeDump ...BeforeDump) ([]byte, error)
}

type {{.RepoName}} struct {
	cache Cache
    exec  DBExecuter
}

// New{{.InterfaceName}} - nil cache indicates nocache.
func New{{.InterfaceName}}(c Cache, exec DBExecuter) {{.InterfaceName}} {
	return &{{.RepoName}}{cache: c, exec: exec}
}

// implementation.
{{.MainStruct}}

func (s {{.RepoName}}) Check(ctx context.Context) error {
    stmts := []string{
{{range .Statements}}
{{- .VarName}},
{{end}}
    }
	for _, v := range stmts {
		err := func(stmt string) error {
			st, err := s.exec.Prepare(ctx, v)
			if err != nil {
				return err
			}
			defer st.Close()
			return nil
		}(v)
		if err != nil {
			return err
		}
	}
	return nil
}

{{.LoadDump}}

{{range .Queries}}
{{.}}
{{end}}

{{range .Mutations}}
{{.}}
{{end}}

//// SQL Statements
// Table Schema
var CreateTableStmt = "{{.TableSchema}}"

// Mutations and queries SQLs.
{{range .Statements}}
var {{.VarName}} = "{{.EscapedSQL}}"
{{end}}

//// Misc helpers
type Option struct {
	v interface{}
}

func TxExec(exec DBExecuter) Option {
	return Option{v: txExecOption{exec: exec}}
}

type txExecOption struct {
	exec DBExecuter
}

func CacheNoRead() Option {
	return Option{v: cacheOption{noread: true}}
}

type cacheOption struct {
	noread bool
}

// nolint: unused
func (s {{.RepoName}}) getExec(options []Option) DBExecuter {
	for _, option := range options {
		switch v := option.v.(type) {
		case txExecOption:
			return v.exec
		}
	}
	return s.exec
}

// nolint: unused
func (s {{.RepoName}}) isCacheNoRead(options []Option) bool {
	for _, option := range options {
		switch v := option.v.(type) {
		case cacheOption:
			return v.noread
		}
	}
	return false
}

////  utils
// replace the (?)s to (?,?,?...)s. The number of ? is @p sz
// XXX(yumin): we use place holder to replace first, to avoid real one (?).
func replaceInCond(sql string, sz ...int) (string, error) {
	const listPlaceholderSymbol = "$#L#$"
	sql = strings.Replace(sql, "(?)", listPlaceholderSymbol, len(sz))
	for _, listsz := range sz {
        if listsz == 0 {
            return sql, ErrEmptyListArg
        }
		var builder strings.Builder
		if listsz > 0 {
			builder.WriteString("(")
			builder.WriteString("?")
			for i := 1; i < listsz; i++ {
				builder.WriteString(",?")
			}
			builder.WriteString(")")
		}
		sql = strings.Replace(sql, listPlaceholderSymbol, builder.String(), 1)
	}
	return sql, nil
}

// support T(int64, float64, string, bool, time.Time), *T, []T, and *[]T.
func valueToString(input interface{}) string {
	val := reflect.ValueOf(input)
	if !val.IsValid() {
		return "<nil>"
	}
	switch val.Kind() {
	case reflect.Int64, reflect.Int:
		return strconv.FormatInt(val.Int(), 10)
	case reflect.Float64:
		return strconv.FormatFloat(val.Float(), 'g', -1, 64)
	case reflect.String:
		return val.String()
	case reflect.Bool:
		if val.Bool() {
			return "true"
		}
		return "false"
	case reflect.Ptr:
		if val.IsNil() {
			return "<nil>"
		}
		return valueToString(val.Elem().Interface())
	case reflect.Array, reflect.Slice:
		v := val
		str := "{"
		for i := 0; i < v.Len(); i++ {
			if i > 0 {
				str += ", "
			}
			str += valueToString(v.Index(i).Interface())
		}
		str += "}"
		return str
	case reflect.Struct:
		i := val.Interface()
		if t, ok := i.(time.Time); ok {
			return strconv.FormatInt(t.Unix(), 10)
		}
		panic("valueToString: unsupported struct " + val.Type().String())
	default:
		panic("valueToString: can't print type " + val.Type().String())
	}
}

var _ = fmt.Sprint("")
var _ = time.Now()
var _ = strings.Compare("", "")
var _ = &sql.Rows{}
var _ = context.Background()
var _ = json.RawMessage{}

//// dependency interfaces
// ErrEmptyListArg passing an empty list argument at runtime.
var ErrEmptyListArg = errors.New("ErrEmptyListArg")

// PassThroughFunc is the function that hits the db.
type PassThroughFunc = func() (interface{}, error)

// Cache is the interface that the cache layer must statisfy.
type Cache interface {
	Get(ctx context.Context, key string, vtype interface{},
		ttl time.Duration, f PassThroughFunc, noCache bool) (interface{}, error)

	Set(ctx context.Context, key string, val interface{}, ttl time.Duration) (error)

    Invalidate(ctx context.Context, key string) error
}

// InvalidateFunc is the type of function that invalidate cache.
type InvalidateFunc = func() error

// DBExecuter wraps transaction and non-transaction db calls
type DBExecuter interface {
	Invalidate(InvalidateFunc) error
	Query(ctx context.Context, unprepared string, args ...interface{}) (*sql.Rows, error)
	Exec(ctx context.Context, unprepared string, args ...interface{}) (sql.Result, error)
    Prepare(ctx context.Context, query string) (*sql.Stmt, error)
}

// rowScanner is implemented by sql.Row and sql.Rows
type rowScanner interface {
	Scan(dest ...interface{}) error
}
